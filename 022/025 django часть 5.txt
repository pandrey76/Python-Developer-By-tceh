

Статья:	https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/

docker - ???

Но некоторые задачи не будут вписываться в Rest, есть некоторые действия пользователей, которые нельзя описать в виде объектов,
например есть приложение, где нужно звонить, пользователь звонит, другой абонент может взять трубку, или скинуть, 
реализация Rest нужна была для получения статистики по звонкам,
у автора в терминах Rest не удалось это описать, поэтому в этой конкретно задаче появился условно CALL, а у CALL появился ACCEPT и DECLINE, этот стиль больше похож на RPC.
Здесь присутствует и ещё один метод, когда сам звонящий может отменить звонок.

00:32 
Если говорить например про чатик, то там есть сущность "Пользователь", "Сообщение", которое можно Удалять, Создавать, Редактировать и т.д. это очень хорошо ложится на Rest. 
Обычно на Rest не ложаться вещи, которые часто завязаны с внешними сервисами, у которых есть специфические ситуации поведения. 
Проектировать Rest намного приятней, мы всегда знаем, что мы проектируем, мы не проектируем запросы, вызовы функций, а мы всегда проектируем коллекцию объектов, т.е. объекты это наши данные, 
а наши данные это то. что мы показываем пользователю. Если мы говорим о каких то сложных специфических случаев, собирание статистики или оборачивание другого API, то наверное RPC будет предпочтительнее.   
 
REST (Representational state transfer)
	• REST - передача состояний объектов
	• REST работает поверх HTTP
	• REST может работать с XML, JSON
	
	Rest это стандарт. он может работать поверж любых протоколов, которые поддерживают те идеи, которые он провозглашает, нам достаточно иметь возможность предать тектовые данные, или любые данные,
которые в результате превратятся в текст. И второе иметь разные методы и некие уникальные идентификаторы (uri) куда мы это передаём.

	Формат данных
Rest никаким образом не связан с форматом данных. Мы можем Рестом отдавать XML, JSON, свой собственный формат, который придумаем. У Реста нет никаких ограничений ни на протокол ни на формат, т.е. Rest применим 
в условиях другого протокола и другого формата данных.


Ссылка:	www.restapitutorial.com

		Принципы REST
	• Uniform Interface 
	• Stateless Interactions - взаимодействия у которых нет состояний. Я должен, что то запросить , я это запрашиваю так, чтоб все понимали контекст в котором я это запрашиваю, а во вторых чтобы были все даннын о моём запросе.
	                           чего у нас не может быть, у нас не может быть состояния. Всё состояние должно помещаться в один запрос. Пример с авторизацией.
	
	• Cacheable
	• Client-Server
	• Layered System -  система должна состоять из нескольких слоёв. Идея такая, что нам можно по этому уникальному пути, делать эти запросы и как бы у нас инфроструктурно сервер не был , он всё равно клиенту ответит, то что 
						клиент от него ожидает. У RPC это может быть не так. Многослойная архитектура определяет, что инфраструктура никак не связанна с данными, это концепция которая всегда выполняется на большенстве WEB серверов.
	• Code on Demand (опционально) - выполнение кода по требованию. Не простая тема она в основном для клиентов и в основном для JS который умеет выполнять некоторый код, когда пришёл ответ. 
	Данная тема в рамках данной лекции не будет освещена!! 
	
	
	Библиотеки
	• flask-restful http://flask-restful-cn.readthedocs.io/en/0.3.4/
	• Django Rest Framework http://www.django-rest-framework.org/
	• Много их
	
	Как определить, что документация хорошая, в ней должно быть много примеров и сама документация по объёму должна быть большой.
	
	01:04
	
	
	
	В  PyCharm есть дополнительные комманды (View->Tool Window->TODO), с которыми он может работать это
		TODO: - Это улачшение или поставить задачу другим, что нужно сделать. Опционально: TODO (Prapor): - в скобках кому нужно сделать.
		FIXME: - Это означает, что всё очень плохо уже сейчас ты это понимаешь, но тебе нужно делать Release и ты делаешь грязь, чтобы её потом поправить.
		
Например:		
	class UserSerializer(serializers.HyperlinkedModelSerializer):
    """
    This class is used to show users, but favourite_pizza can not be saved.
   
    """
	#TODO: add possibility to save favourite_pizza
	
	Все TODO можно найти, через опцию "Find in path" (Right Click на проект->Find in path (Ctrl+Shift+F)), здесь можно осуществлять всю функциональность поиск по RegEx, замена и т.д.
	
	
	 Wooey - F Django app that creates automatic web Urls for Python scripts.
	 
	 
	 Для REST API обычно не выводятся id, потомы что злоумышленник по id может получить ещё закрытую информацию из базы. Если будете выводить id выводите UUID.
	 
	 
	 Добавляем в наш REST ингридиенты
	 
	
Первая задача:

	class PizzaMenuItemSerializer(serializers.HyperlinkedModelSerializer):
    """
    This class is used to get the pizza menu items.
    But it does not show ingredients.

    TODO: add ingredients
    """

    #ingredients = srializer.PrimaryKeyRelatedField(many=True, read_only=True)
	#ingredients = srializer.PrimaryKeyRelatedField(many=True)	#Ошибка надо readonly или передать список полей в виде QuerySet
	ingredients = srializer.PrimaryKeyRelatedField(many=True, queryset=PizzaIngredient.objects.all())
	
	
	class Meta:
        model = PizzaMenuItem
        fields = ('id', 'name')

		
Вторая задача (Нам нужна возможность добавить пользователю FavoritePizza)	
 	
    class UserSerializer(serializers.HyperlinkedModelSerializer):
    """
    This class is used to show users, but favourite_pizza can not be saved.

    TODO: add possibility to save favourite_pizza
    """
    class Meta:
        model = CustomUser
        fields = (
            'id',
            'username',
            'email',
            'our_note',
            'favourite_pizza',
        )

    #Нам не нужен список ингридиентов, нам нужно название любимой пиццы
	#favourite_pizza = PizzaMenuItemSerializer(required=False) 
	favourite_pizza = SlugRelatedField(slug_field="name", queryset=PizzaMenuItem.objects.all()) #Здесь не выполнится выкачка всех объектов из базы, произойдёт запрос PizzaMenuItem.objects.all().filter(slug = "name")
																								# Поэтому это достаточно оптимальная опереация.
	
	
	#Переопределяем метод create
	#из метода create нам нужно вернуть инстанс.
	def create(self, validated_data):
		print( validated_data)
		
	#Переопределяем метод update
	#из метода create нам нужно вернуть инстанс.
	def update(self, instance, validated_data):
		print(instance, validated_data)
			  
			  
 02:18	


 Надо обязательно разобраться в документации на Django REST Framework, для использования его в своём проекте. Сейчас использование REST API это необходимость. Например какому-нибудь внешнему клиенту,
 либо своему frontendу, который работает на React, лоибо передать какую-нибудь систему сбора статистики и метрики и т.д. В любом случае нам это потребуется.
 
 
		Обработка ошибок
	У Django есть хороший параметр (django settings logging см.Документацию) и там есть разные возможности как именно форматировать наши логи, во первых эти логи можно подключать к различным внешним системам 
	сбора логов. Есть разные системы сбора логов: Logrotate, syslog, лучше всего писать логи в такие системы, чтобы они объединялись в некое единое целое и у нас не будет кучи файлов, которые будут разбросаны 
	по файловой систеиме, непонятно кем и когда написанным и т.д. Но Django может некоторые дополнительные поля дополнять или наоборот убирать, т.е. мы можем это сами сконфигурировать. Эта информация полезна
	только тому кто всё это сопровождает. 
	
	• Для обработки ошибок используются специальные системы, они используют "умное" логирование - это логирование в некую систему, которая может делать кучу разных операций с этими логами, например на сколько часто 
	эта проблема случается. у какого типа пользователей, с каких опреационных систем они заходили, какая у них версия браузера и т.д (например sentry).
	.
	• Такие системы необходимы для использования в реальной работе 
	• Они используются как дополнение к стандартному логированию, либо полная его замена.
	
	sentry - эта штука работает для backenda и для frontendа. Для неё необходим отдельный сервер, обязательно https нам нужно устанавливать клиентские библиотеки на все наши сервисы, которые занимаются
	непосредственно backendом, frontendом, мобильные клиенты и т.д., т.е. в centry мы не можем писать print, и что то напишется, это так не работает, там есть специальная библиотека с документацией которую нужно использовать. 
	Но этот гиморой того стоит!!!  Единственный минус это надо настраивать и поддерживать.
	Настраивать можно с помощью утилитки "ansable" - это следующий шаг. Об этом будет разговор на уроке deplodie нашего приложения, в ansable-script это делается в две команды, сначала устанавливаем зависимость потом
    нажимаем установить и всё работает. 	
	
	
	Социальная авторизация, т.е. авторизация через социальные сети, наличие дополнительных кнопочек на странице (вКонтакте, Однокласники и т.д.)

	•	python-social-auth реализуют поддержку почти все известных провайдеров авторизации

	•	Есть альтернативы: python-allauth
	
	С facebookом могут быть проблемы!!!
	
	Проект для всех python web frameworkов (провайдеров) в том числе и для Django: https://github.com/python-social-auth.
	
	Поддерживается протокол OAuth
	•	Протокол, который позволяет нам осуществлять такую авторизацию называется OAuth, у него есть две версии: OAuth и OAuth 2 
	•   Особенность такой авторизации в том, что нет необходимости передавать пароль от сервиса, есть возможность выдавать разрешения на действия и ресурсы.
	
	Для интеграции в Django необходимо добавить в AUTHENTICATION_BACKENDS ещё одну строчку ну ещё настройки. которые нам потребуются.
	
	
	Достаточно просто внедрить,  можно за 20 минут после прочтения документации, сложность получения токенов от социальных сетей, т.к. постоянно меняется дизайн.
	
	Статья про OAuth:	https://geektimes.ru/post/77648/
	
	
		Django CMS - достаточно неплохая CMS, которая многое умеет, а всё остальное через боль.

	• Позволяет управлять контентом, с помощью Django CMS может быть изменён.
	• Хранит все версии редактируемых документов, позволяет осуществлять премодерацию, опубликовывать изменения по желанию
	• Имеет широкие возможности по расширению
	• Заставляет изменить способ проектирования приложения
	
		Очень большие проблемы при совместном использовании Django CMS и React.
	Если нам когда-нибудь понадобится сделать лендинг и мы будем брать Django CMS, никогда этого не делайте, потомц что люди начнут наглеть и просить менять из CMS всё подряд. И вы вынуждены будите 
	писать плагины под лендинг, который можно было сверстать на коленке за 15 минут.
		Django CMS хороша следующим, если у нас действительно сложный портал, на котором редактора будут писать статьи и добавлять уникальный контент, возможно будут создавать новые страницы
		какие-то промо материалы и т.д., для этого Django CMS хороший вариант. Естественно Django CMS ограничено своим функционалом, и получается многие вещи с Django CMS сделать просто, а некоторые очень сложно.
		
		Сложности 02:45 (Описание примера)
		
		Есть альтернативы: BackTale, автору не очень нравится, т.к. всё делается с помощью миграции моделей, меняем что то на странице, делаем миграцию к базе, считает не логичным.
		
		WordPress самая не безопасная CMS.
		
		Django CMS нам становится нужна в тот момент, когда к нам приходит бизнес и говорит: "Я хочу, чтобы можно было всё менять!" Не что то одно, а ключевое слово всё.
		В документации на Django CMS всё достаточно подробно описанно! Хорошая документация!
		Автор говорит, что Django CMS достаточно хороший продукт! 
		CMS на PHP полная хрень (Joomla!!).
		Исключение Bitrix, который интегрирован с 1-С, а на 1-С очень много завязано в российском бизнесе. Большая простота внедрения всего, например написать магазин на Bitrix намного проще, чем на Django.